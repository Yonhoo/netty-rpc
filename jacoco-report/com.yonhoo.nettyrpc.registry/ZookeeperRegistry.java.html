<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ZookeeperRegistry.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">netty-rpc</a> &gt; <a href="index.source.html" class="el_package">com.yonhoo.nettyrpc.registry</a> &gt; <span class="el_source">ZookeeperRegistry.java</span></div><h1>ZookeeperRegistry.java</h1><pre class="source lang-java linenums">package com.yonhoo.nettyrpc.registry;


import com.yonhoo.nettyrpc.common.Destroyable;
import com.yonhoo.nettyrpc.common.RpcConstants;
import com.yonhoo.nettyrpc.config.RegistryPropertiesConfig;
import com.yonhoo.nettyrpc.exception.RpcErrorCode;
import com.yonhoo.nettyrpc.exception.RpcException;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.Map;
import java.util.concurrent.*;
import java.util.stream.Collectors;

import com.yonhoo.nettyrpc.util.RegistryUtils;
import lombok.extern.slf4j.Slf4j;
import org.apache.curator.RetryPolicy;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.framework.imps.CuratorFrameworkState;
import org.apache.curator.framework.recipes.cache.CuratorCache;
import org.apache.curator.framework.recipes.cache.CuratorCacheListener;
import org.apache.curator.retry.ExponentialBackoffRetry;
import org.apache.zookeeper.CreateMode;
import org.springframework.stereotype.Component;

<span class="fc" id="L29">@Slf4j</span>
@Component
public class ZookeeperRegistry implements Registry, Destroyable {

    public static final String CONTEXT_SEP = &quot;/&quot;;
    private CuratorFramework zkClient;
    private final RegistryConfig registryConfig;
<span class="fc" id="L36">    private final ZookeeperProviderObserver providerObserver = new ZookeeperProviderObserver();</span>
    private static final ConcurrentMap&lt;ConsumerConfig, CuratorCache&gt;
<span class="fc" id="L38">            INTERFACE_PROVIDER_CACHE = new ConcurrentHashMap&lt;&gt;();</span>

<span class="fc" id="L40">    private static final ConcurrentLinkedQueue&lt;String&gt; SERVICE_PATHS = new ConcurrentLinkedQueue&lt;&gt;();</span>

<span class="fc" id="L42">    public ZookeeperRegistry(RegistryPropertiesConfig registryPropertiesConfig) {</span>
<span class="fc" id="L43">        registryConfig = RegistryConfig.builder()</span>
                // unique application
<span class="fc" id="L45">                .rootPath(registryPropertiesConfig.getApplication())</span>
<span class="fc" id="L46">                .address(registryPropertiesConfig.getAddress())</span>
<span class="fc" id="L47">                .connectTimeout(60000)</span>
<span class="fc" id="L48">                .port(registryPropertiesConfig.getPort())</span>
<span class="fc" id="L49">                .build();</span>

<span class="pc bpc" id="L51" title="1 of 2 branches missed.">        if (!registryConfig.getRootPath().endsWith(CONTEXT_SEP)) {</span>
<span class="fc" id="L52">            registryConfig.setRootPath(registryConfig.getRootPath() + CONTEXT_SEP);</span>
        }

<span class="fc" id="L55">        String address = registryConfig.getAddress() + &quot;:&quot; + registryConfig.getPort();</span>

<span class="fc" id="L57">        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);</span>
<span class="fc" id="L58">        CuratorFrameworkFactory.Builder zkClientBuilder = CuratorFrameworkFactory.builder()</span>
<span class="fc" id="L59">                .connectString(address)</span>
<span class="fc" id="L60">                .sessionTimeoutMs(registryConfig.getConnectTimeout() * 3)</span>
<span class="fc" id="L61">                .connectionTimeoutMs(registryConfig.getConnectTimeout())</span>
<span class="fc" id="L62">                .canBeReadOnly(false)</span>
<span class="fc" id="L63">                .retryPolicy(retryPolicy)</span>
<span class="fc" id="L64">                .defaultData(null);</span>

<span class="fc" id="L66">        zkClient = zkClientBuilder.build();</span>

<span class="fc" id="L68">        zkClient.start();</span>

<span class="pc bpc" id="L70" title="1 of 2 branches missed.">        if (CuratorFrameworkState.STARTED != zkClient.getState()) {</span>
<span class="nc" id="L71">            log.error(&quot;client status: {}&quot;, zkClient.getState().toString());</span>
<span class="nc" id="L72">            throw RpcException.with(RpcErrorCode.REGISTRY_CLIENT_START_EXCEPTION);</span>
        }
<span class="fc" id="L74">    }</span>

    public CuratorFramework getZkClient() {
<span class="fc" id="L77">        return zkClient;</span>
    }

    @Override
    public void registry(ProviderConfig providerConfig) {
<span class="pc bpc" id="L82" title="1 of 2 branches missed.">        if (providerConfig.isRegistered()) {</span>
<span class="nc" id="L83">            log.warn(&quot;provider config already registered: {}&quot;, providerConfig);</span>
<span class="nc" id="L84">            return;</span>
        }

        try {
<span class="fc" id="L88">            String providerPath = ZookeeperRegistryHelper.buildProviderPath(registryConfig.getRootPath(),</span>
<span class="fc" id="L89">                    providerConfig.getProviderName());</span>

<span class="fc bfc" id="L91" title="All 2 branches covered.">            for (ServiceConfig serviceConfig : providerConfig.getServiceConfigList()) {</span>
<span class="fc" id="L92">                String metaData = ZookeeperRegistryHelper.convertMetaData(providerConfig, serviceConfig);</span>

<span class="fc" id="L94">                String encodeData = URLEncoder.encode(metaData, StandardCharsets.UTF_8);</span>

<span class="fc" id="L96">                String servicePath = providerPath + CONTEXT_SEP + serviceConfig.getUrl();</span>

<span class="fc" id="L98">                log.info(&quot;registry server path: {}&quot;, servicePath);</span>

<span class="fc" id="L100">                SERVICE_PATHS.add(servicePath);</span>

<span class="fc" id="L102">                getAndCheckZkClient().create().creatingParentContainersIfNeeded()</span>
<span class="fc" id="L103">                        .withMode(CreateMode.EPHEMERAL)</span>
<span class="fc" id="L104">                        .forPath(servicePath, encodeData.getBytes());</span>
<span class="fc" id="L105">            }</span>
<span class="nc" id="L106">        } catch (Exception e) {</span>
<span class="nc" id="L107">            log.error(&quot;registry config error&quot;, e);</span>
<span class="fc" id="L108">        }</span>

<span class="fc" id="L110">        providerConfig.setRegistered(true);</span>
<span class="fc" id="L111">    }</span>

    private CuratorFramework getAndCheckZkClient() {
<span class="fc" id="L114">        checkZkClient();</span>
<span class="fc" id="L115">        return zkClient;</span>
    }

    private void checkZkClient() {
<span class="pc bpc" id="L119" title="2 of 4 branches missed.">        if (zkClient == null || zkClient.getState() != CuratorFrameworkState.STARTED) {</span>
<span class="nc" id="L120">            log.error(&quot;client status: {}&quot;, zkClient.getState().toString());</span>
<span class="nc" id="L121">            throw RpcException.with(RpcErrorCode.REGISTRY_CLIENT_UNAVAILABLE);</span>
        }
<span class="fc" id="L123">    }</span>

    @Override
    public boolean unRegistry(ProviderConfig providerConfig) {
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">        if (!providerConfig.isRegistered()) {</span>
<span class="nc" id="L128">            log.warn(&quot;provider config was not registered&quot;);</span>
<span class="nc" id="L129">            return false;</span>
        }
        try {

<span class="fc" id="L133">            String providerPath = ZookeeperRegistryHelper.buildProviderPath(registryConfig.getRootPath(),</span>
<span class="fc" id="L134">                    providerConfig.getProviderName());</span>

<span class="fc bfc" id="L136" title="All 2 branches covered.">            for (ServiceConfig serviceConfig : providerConfig.getServiceConfigList()) {</span>

<span class="fc" id="L138">                String servicePath = providerPath + CONTEXT_SEP + serviceConfig.getUrl();</span>

<span class="fc" id="L140">                getAndCheckZkClient()</span>
<span class="fc" id="L141">                        .delete()</span>
<span class="fc" id="L142">                        .forPath(servicePath);</span>

<span class="fc" id="L144">            }</span>
<span class="nc" id="L145">        } catch (Exception e) {</span>
<span class="nc" id="L146">            log.error(&quot;registry config error&quot;, e);</span>
<span class="fc" id="L147">        }</span>

<span class="fc" id="L149">        providerConfig.setRegistered(false);</span>

<span class="fc" id="L151">        return true;</span>
    }

    // no retry after subscribe fail
    @Override
    public void subscribe(final ConsumerConfig config) throws InterruptedException {

<span class="fc" id="L158">        checkZkClient();</span>

<span class="fc" id="L160">        String providerPath = ZookeeperRegistryHelper.buildProviderPath(registryConfig.getRootPath(),</span>
<span class="fc" id="L161">                config.getConsumerInterface());</span>

<span class="fc" id="L163">        log.info(&quot;subscribe providerPath {}&quot;, providerPath);</span>

<span class="fc" id="L165">        CuratorCache curatorCache = CuratorCache.build(zkClient, providerPath);</span>

<span class="fc" id="L167">        CuratorCacheListener curatorCacheListener = CuratorCacheListener.builder()</span>
<span class="fc" id="L168">                .forCreates(childData -&gt; providerObserver.addProvider(config, providerPath, childData))</span>
<span class="pc" id="L169">                .forChanges((oldChildData, childData) -&gt; providerObserver.updateProvider(config, providerPath, childData))</span>
<span class="fc" id="L170">                .forDeletes(childData -&gt; providerObserver.removeProvider(config, providerPath, childData))</span>
<span class="fc" id="L171">                .build();</span>

<span class="fc" id="L173">        curatorCache.listenable().addListener(curatorCacheListener);</span>

<span class="fc" id="L175">        curatorCache.start();</span>

<span class="fc" id="L177">        INTERFACE_PROVIDER_CACHE.put(config, curatorCache);</span>
<span class="fc" id="L178">        providerObserver.addProviderListener(config, config.getProviderInfoListener());</span>

<span class="fc" id="L180">    }</span>

    @Override
    public void subscribe(ConsumerConfig config, long waitTime, TimeUnit timeUnit) throws InterruptedException {
<span class="fc" id="L184">        this.subscribe(config);</span>
<span class="fc" id="L185">        CountDownLatch countDownLatch = new CountDownLatch(1);</span>
<span class="fc" id="L186">        countDownLatch.await(waitTime, timeUnit);</span>
<span class="fc" id="L187">    }</span>

    @Override
    public void unSubscribe(ConsumerConfig config) {
<span class="fc" id="L191">        checkZkClient();</span>
<span class="fc" id="L192">        log.info(&quot;unSubscribe consumer {}&quot;, config.getConsumerInterface());</span>
<span class="fc" id="L193">        providerObserver.removeProviderListener(config);</span>
<span class="fc" id="L194">        CuratorCache childCache = INTERFACE_PROVIDER_CACHE.remove(config);</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">        if (childCache != null) {</span>
            try {
<span class="fc" id="L197">                List&lt;ProviderInfo&gt; providerInfos = childCache.stream()</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">                        .filter(childData -&gt; !RegistryUtils.isRootPath(childData.getPath()))</span>
<span class="fc" id="L199">                        .map(childData -&gt; {</span>
<span class="fc" id="L200">                            String providerPath = RegistryUtils.getProviderPath(childData.getPath());</span>
<span class="fc" id="L201">                            String rootPath = RegistryUtils.getRootPath(childData.getPath());</span>
<span class="fc" id="L202">                            String[] portWithAddress = providerPath.split(&quot;:&quot;);</span>
<span class="fc" id="L203">                            Map&lt;String, String&gt; dataMap = RegistryUtils.buildStringMapFromBytes(childData);</span>

<span class="fc" id="L205">                            return ProviderInfo.builder()</span>
<span class="fc" id="L206">                                    .rootPath(rootPath)</span>
<span class="fc" id="L207">                                    .servicePath(childData.getPath())</span>
<span class="fc" id="L208">                                    .port(Integer.valueOf(portWithAddress[1]))</span>
<span class="fc" id="L209">                                    .address(portWithAddress[0])</span>
<span class="fc" id="L210">                                    .weight(Double.parseDouble(dataMap.getOrDefault(RpcConstants.SERVICE_WEIGHT, &quot;0.0&quot;)))</span>
<span class="fc" id="L211">                                    .providerName(dataMap.getOrDefault(RpcConstants.PROVIDER_NAME, null))</span>
<span class="fc" id="L212">                                    .build();</span>
                        })
<span class="fc" id="L214">                        .collect(Collectors.toList());</span>

<span class="fc" id="L216">                providerInfos.stream().forEach(providerInfo -&gt; {</span>
<span class="fc" id="L217">                    log.info(&quot;remove provider {}&quot;, providerInfo);</span>
<span class="fc" id="L218">                    config.getProviderInfoListener().removeProvider(providerInfo);</span>
<span class="fc" id="L219">                });</span>

<span class="fc" id="L221">                childCache.close();</span>
<span class="nc" id="L222">            } catch (Exception e) {</span>
<span class="nc" id="L223">                log.error(&quot;unsubscribe consumer config : {}&quot;, e);</span>
<span class="nc" id="L224">                throw RpcException.with(RpcErrorCode.REGISTRY_UNSUBSCRIBE_EXCEPTION);</span>
<span class="fc" id="L225">            }</span>
        }

<span class="fc" id="L228">    }</span>

    @Override
    public void destroy() {
<span class="pc bpc" id="L232" title="1 of 4 branches missed.">        if (zkClient != null &amp;&amp; zkClient.getState() == CuratorFrameworkState.STARTED) {</span>
<span class="fc" id="L233">            INTERFACE_PROVIDER_CACHE.forEach((consumerConfig, curatorCache) -&gt;</span>
<span class="fc" id="L234">                    unSubscribe(consumerConfig));</span>

<span class="fc" id="L236">            INTERFACE_PROVIDER_CACHE.clear();</span>

<span class="fc" id="L238">            SERVICE_PATHS.forEach((servicePath) -&gt; {</span>
                try {
<span class="fc" id="L240">                    getAndCheckZkClient()</span>
<span class="fc" id="L241">                            .delete()</span>
<span class="fc" id="L242">                            .forPath(servicePath);</span>
<span class="fc" id="L243">                } catch (Exception e) {</span>
<span class="fc" id="L244">                    log.warn(&quot;delete service path error {}&quot;, servicePath, e);</span>
<span class="fc" id="L245">                }</span>
<span class="fc" id="L246">            });</span>

<span class="fc" id="L248">            SERVICE_PATHS.clear();</span>

<span class="fc" id="L250">            zkClient.close();</span>
        }
<span class="fc" id="L252">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>